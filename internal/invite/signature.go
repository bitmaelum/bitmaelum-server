package invite

import (
	"crypto/sha256"
	"encoding/base64"
	"strconv"
	"strings"
	"time"

	"github.com/bitmaelum/bitmaelum-suite/pkg/bmcrypto"
	"github.com/bitmaelum/bitmaelum-suite/pkg/hash"
)

// override for testing purposes
var timeNow = time.Now

// Token holds all info for an invitation
type Token struct {
	Address   hash.Hash
	RoutingID string
	Expiry    time.Time
	Signature []byte
}

// ParseInviteToken parses data as generated by inviteToken.String() into a token
func ParseInviteToken(data string) (*Token, error) {
	it := &Token{}

	tokenData, err := base64.StdEncoding.DecodeString(data)
	if err != nil {
		return nil, err
	}

	parts := strings.SplitN(string(tokenData), ":", 4)
	if len(parts) != 4 {
		return nil, err
	}

	// Convert all parts to the correct formats
	a, err := hash.NewFromHash(parts[0])
	if err != nil {
		return nil, err
	}
	it.Address = *a

	it.RoutingID = parts[1]
	i, err := strconv.ParseInt(parts[2], 10, 64)
	if err != nil {
		return nil, err
	}

	it.Expiry = time.Unix(i, 0)
	it.Signature = []byte(parts[3])

	return it, nil
}

// NewInviteToken will create a new invitation token that can be used to create an address on a mailserver
func NewInviteToken(addr hash.Hash, routingID string, validUntil time.Time, pk bmcrypto.PrivKey) (*Token, error) {
	h := generateHash(addr, routingID, validUntil)
	sig, err := bmcrypto.Sign(pk, h)
	if err != nil {
		return nil, err
	}

	return &Token{
		Address:   addr,
		RoutingID: routingID,
		Expiry:    validUntil,
		Signature: sig,
	}, nil
}

// String converts a invite token to a string representation
func (token *Token) String() string {
	s := token.Address.String() + ":" + token.RoutingID + ":" + strconv.FormatInt(token.Expiry.Unix(), 10) + ":" + string(token.Signature)
	return base64.StdEncoding.EncodeToString([]byte(s))
}

// Verify will verify a token/signature against the given data
func (token *Token) Verify(routingID string, pubKey bmcrypto.PubKey) bool {
	// check signature
	h := generateHash(token.Address, token.RoutingID, token.Expiry)
	ok, err := bmcrypto.Verify(pubKey, h, token.Signature)
	if err != nil {
		return false
	}

	// Make sure we don't accept tokens after the valid Until date
	if timeNow().After(token.Expiry) {
		return false
	}

	// Must be the same routing ID
	if token.RoutingID != routingID {
		return false
	}

	return ok
}

func generateHash(addr hash.Hash, routingID string, validUntil time.Time) []byte {
	h := sha256.Sum256([]byte(addr.String() + routingID + strconv.FormatInt(validUntil.Unix(), 10)))

	return h[:]
}
